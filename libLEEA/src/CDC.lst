GAS LISTING /tmp/cc9TtpNu.s 			page 1


   1               		.file	"CDC.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.stabs	"/tmp/L3/src/",100,0,2,.Ltext0
   8               		.stabs	"CDC.c",100,0,2,.Ltext0
   9               		.text
  10               	.Ltext0:
  11               		.stabs	"gcc2_compiled.",60,0,0,0
  12               		.stabs	"int:t(0,1)=r(0,1);-32768;32767;",128,0,0,0
  13               		.stabs	"char:t(0,2)=r(0,2);0;127;",128,0,0,0
  14               		.stabs	"long int:t(0,3)=@s32;r(0,3);020000000000;017777777777;",128,0,0,0
  15               		.stabs	"unsigned int:t(0,4)=r(0,4);0;0177777;",128,0,0,0
  16               		.stabs	"long unsigned int:t(0,5)=@s32;r(0,5);0;037777777777;",128,0,0,0
  17               		.stabs	"__int128:t(0,6)=@s128;r(0,6);02000000000000000000000000000000000000000000;0177777777777777
  18               		.stabs	"__int128 unsigned:t(0,7)=@s128;r(0,7);0;03777777777777777777777777777777777777777777;",128
  19               		.stabs	"long long int:t(0,8)=@s64;r(0,8);01000000000000000000000;00777777777777777777777;",128,0,0
  20               		.stabs	"long long unsigned int:t(0,9)=@s64;r(0,9);0;01777777777777777777777;",128,0,0,0
  21               		.stabs	"short int:t(0,10)=r(0,10);-32768;32767;",128,0,0,0
  22               		.stabs	"short unsigned int:t(0,11)=r(0,11);0;0177777;",128,0,0,0
  23               		.stabs	"signed char:t(0,12)=@s8;r(0,12);-128;127;",128,0,0,0
  24               		.stabs	"unsigned char:t(0,13)=@s8;r(0,13);0;255;",128,0,0,0
  25               		.stabs	"float:t(0,14)=r(0,1);4;0;",128,0,0,0
  26               		.stabs	"double:t(0,15)=r(0,1);4;0;",128,0,0,0
  27               		.stabs	"long double:t(0,16)=r(0,1);4;0;",128,0,0,0
  28               		.stabs	"short _Fract:t(0,17)=r(0,1);1;0;",128,0,0,0
  29               		.stabs	"_Fract:t(0,18)=r(0,1);2;0;",128,0,0,0
  30               		.stabs	"long _Fract:t(0,19)=r(0,1);4;0;",128,0,0,0
  31               		.stabs	"long long _Fract:t(0,20)=r(0,1);8;0;",128,0,0,0
  32               		.stabs	"unsigned short _Fract:t(0,21)=r(0,1);1;0;",128,0,0,0
  33               		.stabs	"unsigned _Fract:t(0,22)=r(0,1);2;0;",128,0,0,0
  34               		.stabs	"unsigned long _Fract:t(0,23)=r(0,1);4;0;",128,0,0,0
  35               		.stabs	"unsigned long long _Fract:t(0,24)=r(0,1);8;0;",128,0,0,0
  36               		.stabs	"_Sat short _Fract:t(0,25)=r(0,1);1;0;",128,0,0,0
  37               		.stabs	"_Sat _Fract:t(0,26)=r(0,1);2;0;",128,0,0,0
  38               		.stabs	"_Sat long _Fract:t(0,27)=r(0,1);4;0;",128,0,0,0
  39               		.stabs	"_Sat long long _Fract:t(0,28)=r(0,1);8;0;",128,0,0,0
  40               		.stabs	"_Sat unsigned short _Fract:t(0,29)=r(0,1);1;0;",128,0,0,0
  41               		.stabs	"_Sat unsigned _Fract:t(0,30)=r(0,1);2;0;",128,0,0,0
  42               		.stabs	"_Sat unsigned long _Fract:t(0,31)=r(0,1);4;0;",128,0,0,0
  43               		.stabs	"_Sat unsigned long long _Fract:t(0,32)=r(0,1);8;0;",128,0,0,0
  44               		.stabs	"short _Accum:t(0,33)=r(0,1);2;0;",128,0,0,0
  45               		.stabs	"_Accum:t(0,34)=r(0,1);4;0;",128,0,0,0
  46               		.stabs	"long _Accum:t(0,35)=r(0,1);8;0;",128,0,0,0
  47               		.stabs	"long long _Accum:t(0,36)=r(0,1);8;0;",128,0,0,0
  48               		.stabs	"unsigned short _Accum:t(0,37)=r(0,1);2;0;",128,0,0,0
  49               		.stabs	"unsigned _Accum:t(0,38)=r(0,1);4;0;",128,0,0,0
  50               		.stabs	"unsigned long _Accum:t(0,39)=r(0,1);8;0;",128,0,0,0
  51               		.stabs	"unsigned long long _Accum:t(0,40)=r(0,1);8;0;",128,0,0,0
  52               		.stabs	"_Sat short _Accum:t(0,41)=r(0,1);2;0;",128,0,0,0
  53               		.stabs	"_Sat _Accum:t(0,42)=r(0,1);4;0;",128,0,0,0
  54               		.stabs	"_Sat long _Accum:t(0,43)=r(0,1);8;0;",128,0,0,0
  55               		.stabs	"_Sat long long _Accum:t(0,44)=r(0,1);8;0;",128,0,0,0
  56               		.stabs	"_Sat unsigned short _Accum:t(0,45)=r(0,1);2;0;",128,0,0,0
  57               		.stabs	"_Sat unsigned _Accum:t(0,46)=r(0,1);4;0;",128,0,0,0
GAS LISTING /tmp/cc9TtpNu.s 			page 2


  58               		.stabs	"_Sat unsigned long _Accum:t(0,47)=r(0,1);8;0;",128,0,0,0
  59               		.stabs	"_Sat unsigned long long _Accum:t(0,48)=r(0,1);8;0;",128,0,0,0
  60               		.stabs	"void:t(0,49)=(0,49)",128,0,0,0
  61               		.stabs	"../include/USBAPI.h",130,0,0,0
  62               		.stabs	"../include/Platform.h",130,0,0,0
  63               		.stabs	"/usr/lib/avr/include/stdlib.h",130,0,0,0
  64               		.stabs	"/usr/lib/gcc/avr/5.4.0/include/stddef.h",130,0,0,0
  65               		.stabs	"size_t:t(4,1)=(0,4)",128,0,216,0
  66               		.stabs	"wchar_t:t(4,2)=(0,1)",128,0,328,0
  67               		.stabn	162,0,0,0
  68               		.stabs	"div_t:t(3,1)=(3,2)=s4quot:(0,1),0,16;rem:(0,1),16,16;;",128,0,73,0
  69               		.stabs	"ldiv_t:t(3,3)=(3,4)=s8quot:(0,3),0,32;rem:(0,3),32,32;;",128,0,79,0
  70               		.stabs	"__compar_fn_t:t(3,5)=(3,6)=*(3,7)=f(0,1)",128,0,82,0
  71               		.stabn	162,0,0,0
  72               		.stabs	"/usr/lib/avr/include/avr/io.h",130,0,0,0
  73               		.stabs	"/usr/lib/avr/include/avr/sfr_defs.h",130,0,0,0
  74               		.stabs	"/usr/lib/avr/include/inttypes.h",130,0,0,0
  75               		.stabs	"/usr/lib/gcc/avr/5.4.0/include/stdint.h",130,0,0,0
  76               		.stabs	"/usr/lib/avr/include/stdint.h",130,0,0,0
  77               		.stabs	"int8_t:t(9,1)=(0,12)",128,0,125,0
  78               		.stabs	"uint8_t:t(9,2)=(0,13)",128,0,126,0
  79               		.stabs	"int16_t:t(9,3)=(0,1)",128,0,127,0
  80               		.stabs	"uint16_t:t(9,4)=(0,4)",128,0,128,0
  81               		.stabs	"int32_t:t(9,5)=(0,3)",128,0,129,0
  82               		.stabs	"uint32_t:t(9,6)=(0,5)",128,0,130,0
  83               		.stabs	"int64_t:t(9,7)=(0,8)",128,0,132,0
  84               		.stabs	"uint64_t:t(9,8)=(0,9)",128,0,133,0
  85               		.stabs	"intptr_t:t(9,9)=(9,3)",128,0,146,0
  86               		.stabs	"uintptr_t:t(9,10)=(9,4)",128,0,151,0
  87               		.stabs	"int_least8_t:t(9,11)=(9,1)",128,0,163,0
  88               		.stabs	"uint_least8_t:t(9,12)=(9,2)",128,0,168,0
  89               		.stabs	"int_least16_t:t(9,13)=(9,3)",128,0,173,0
  90               		.stabs	"uint_least16_t:t(9,14)=(9,4)",128,0,178,0
  91               		.stabs	"int_least32_t:t(9,15)=(9,5)",128,0,183,0
  92               		.stabs	"uint_least32_t:t(9,16)=(9,6)",128,0,188,0
  93               		.stabs	"int_least64_t:t(9,17)=(9,7)",128,0,196,0
  94               		.stabs	"uint_least64_t:t(9,18)=(9,8)",128,0,203,0
  95               		.stabs	"int_fast8_t:t(9,19)=(9,1)",128,0,217,0
  96               		.stabs	"uint_fast8_t:t(9,20)=(9,2)",128,0,222,0
  97               		.stabs	"int_fast16_t:t(9,21)=(9,3)",128,0,227,0
  98               		.stabs	"uint_fast16_t:t(9,22)=(9,4)",128,0,232,0
  99               		.stabs	"int_fast32_t:t(9,23)=(9,5)",128,0,237,0
 100               		.stabs	"uint_fast32_t:t(9,24)=(9,6)",128,0,242,0
 101               		.stabs	"int_fast64_t:t(9,25)=(9,7)",128,0,250,0
 102               		.stabs	"uint_fast64_t:t(9,26)=(9,8)",128,0,257,0
 103               		.stabs	"intmax_t:t(9,27)=(9,7)",128,0,277,0
 104               		.stabs	"uintmax_t:t(9,28)=(9,8)",128,0,282,0
 105               		.stabn	162,0,0,0
 106               		.stabn	162,0,0,0
 107               		.stabs	"int_farptr_t:t(7,1)=(9,5)",128,0,77,0
 108               		.stabs	"uint_farptr_t:t(7,2)=(9,6)",128,0,81,0
 109               		.stabn	162,0,0,0
 110               		.stabn	162,0,0,0
 111               		.stabs	"/usr/lib/avr/include/avr/fuse.h",130,0,0,0
 112               		.stabs	"__fuse_t:t(10,1)=(10,2)=s3low:(0,13),0,8;high:(0,13),8,8;extended:(0,13),16,8;;",128,0,244
 113               		.stabn	162,0,0,0
 114               		.stabn	162,0,0,0
GAS LISTING /tmp/cc9TtpNu.s 			page 3


 115               		.stabs	"/usr/lib/avr/include/avr/eeprom.h",130,0,0,0
 116               		.stabs	"/usr/lib/gcc/avr/5.4.0/include/stddef.h",130,0,0,0
 117               		.stabs	"ptrdiff_t:t(12,1)=(0,1)",128,0,149,0
 118               		.stabs	"max_align_t:t(12,2)=(12,3)=s12__max_align_ll:(0,8),0,64;__max_align_ld:(0,16),64,32;;",128
 119               		.stabn	162,0,0,0
 120               		.stabn	162,0,0,0
 121               		.stabs	"u8:t(2,1)=(0,13)",128,0,17,0
 122               		.stabs	"u16:t(2,2)=(0,11)",128,0,18,0
 123               		.stabs	"u32:t(2,3)=(0,5)",128,0,19,0
 124               		.stabs	"word:t(2,4)=(0,4)",128,0,103,0
 125               		.stabs	"bool:t(2,5)=(9,2)",128,0,107,0
 126               		.stabs	"byte:t(2,6)=(9,2)",128,0,108,0
 127               		.stabn	162,0,0,0
 128               		.stabs	"Setup:t(1,1)=(1,2)=s8bmRequestType:(9,2),0,8;bRequest:(9,2),8,8;wValueL:(9,2),16,8;wValueH
 129               		.stabn	162,0,0,0
 130               		.stabs	"../include/USBCore.h",130,0,0,0
 131               		.stabs	"DeviceDescriptor:t(13,1)=(13,2)=s18len:(2,1),0,8;dtype:(2,1),8,8;usbVersion:(2,2),16,16;de
 132               		.stabs	"ConfigDescriptor:t(13,3)=(13,4)=s9len:(2,1),0,8;dtype:(2,1),8,8;clen:(2,2),16,16;numInterf
 133               		.stabs	"InterfaceDescriptor:t(13,5)=(13,6)=s9len:(2,1),0,8;dtype:(2,1),8,8;number:(2,1),16,8;alter
 134               		.stabs	"EndpointDescriptor:t(13,7)=(13,8)=s7len:(2,1),0,8;dtype:(2,1),8,8;addr:(2,1),16,8;attr:(2,
 135               		.stabs	"IADDescriptor:t(13,9)=(13,10)=s8len:(2,1),0,8;dtype:(2,1),8,8;firstInterface:(2,1),16,8;in
 136               		.stabs	"CDCCSInterfaceDescriptor:t(13,11)=(13,12)=s5len:(2,1),0,8;dtype:(2,1),8,8;subtype:(2,1),16
 137               		.stabs	"CDCCSInterfaceDescriptor4:t(13,13)=(13,14)=s4len:(2,1),0,8;dtype:(2,1),8,8;subtype:(2,1),1
 138               		.stabs	"CMFunctionalDescriptor:t(13,15)=(13,16)=s5len:(2,1),0,8;dtype:(2,1),8,8;subtype:(2,1),16,8
 139               		.stabs	"ACMFunctionalDescriptor:t(13,17)=(13,18)=s4len:(2,1),0,8;dtype:(2,1),8,8;subtype:(2,1),16,
 140               		.stabs	"CDCDescriptor:t(13,19)=(13,20)=s66iad:(13,9),0,64;cif:(13,5),64,72;header:(13,11),136,40;c
 141               		.stabs	"MSCDescriptor:t(13,21)=(13,22)=s23msc:(13,5),0,72;in:(13,7),72,56;out:(13,7),128,56;;",128
 142               		.stabs	"HIDDescDescriptor:t(13,23)=(13,24)=s9len:(2,1),0,8;dtype:(2,1),8,8;addr:(2,1),16,8;version
 143               		.stabs	"HIDDescriptor:t(13,25)=(13,26)=s25hid:(13,5),0,72;desc:(13,23),72,72;in:(13,7),144,56;;",1
 144               		.stabn	162,0,0,0
 145               		.stabs	"ring_buffer:T(0,50)=s68buffer:(0,51)=ar(0,52)=r(0,52);0;0177777;;0;63;(0,13),0,512;head:(0
 146               		.stabs	"ring_buffer:t(0,54)=(0,50)",128,0,34,0
 147               		.stabs	"LineInfo:t(0,55)=(0,56)=s8dwDTERate:(2,3),0,32;bCharFormat:(2,1),32,8;bParityType:(2,1),40
 148               		.section	.text.CDC_GetInterface,"ax",@progbits
 149               		.stabs	"CDC_GetInterface:F(0,1)",36,0,69,CDC_GetInterface
 150               		.stabs	"interfaceNum:P(0,57)=*(2,1)",64,0,69,30
 151               		.weak	CDC_GetInterface
 152               		.type	CDC_GetInterface, @function
 153               	CDC_GetInterface:
 154               		.stabd	46,0,0
   1:CDC.c         **** /* Copyright (c) 2011, Peter Barrett  
   2:CDC.c         **** **  
   3:CDC.c         **** ** Permission to use, copy, modify, and/or distribute this software for  
   4:CDC.c         **** ** any purpose with or without fee is hereby granted, provided that the  
   5:CDC.c         **** ** above copyright notice and this permission notice appear in all copies.  
   6:CDC.c         **** ** 
   7:CDC.c         **** ** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
   8:CDC.c         **** ** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
   9:CDC.c         **** ** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
  10:CDC.c         **** ** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
  11:CDC.c         **** ** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
  12:CDC.c         **** ** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
  13:CDC.c         **** ** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
  14:CDC.c         **** ** SOFTWARE.  
  15:CDC.c         **** */
  16:CDC.c         **** 
  17:CDC.c         **** //y#include "Platform.h"
GAS LISTING /tmp/cc9TtpNu.s 			page 4


  18:CDC.c         **** #include "USBAPI.h"
  19:CDC.c         **** #include "USBCore.h"
  20:CDC.c         **** #include "USBDesc.h"
  21:CDC.c         **** #include <avr/wdt.h>
  22:CDC.c         **** 
  23:CDC.c         **** #if (RAMEND < 1000)
  24:CDC.c         **** #define SERIAL_BUFFER_SIZE 16
  25:CDC.c         **** #else
  26:CDC.c         **** #define SERIAL_BUFFER_SIZE 64
  27:CDC.c         **** #endif
  28:CDC.c         **** 
  29:CDC.c         **** typedef struct ring_buffer
  30:CDC.c         **** {
  31:CDC.c         **** 	unsigned char buffer[SERIAL_BUFFER_SIZE];
  32:CDC.c         **** 	volatile int head;
  33:CDC.c         **** 	volatile int tail;
  34:CDC.c         **** }ring_buffer;
  35:CDC.c         **** 
  36:CDC.c         **** ring_buffer cdc_rx_buffer = { { 0 }, 0, 0};
  37:CDC.c         **** ring_buffer *_cdc_rx_buffer;
  38:CDC.c         **** 
  39:CDC.c         **** typedef struct
  40:CDC.c         **** {
  41:CDC.c         **** 	u32	dwDTERate;
  42:CDC.c         **** 	u8	bCharFormat;
  43:CDC.c         **** 	u8 	bParityType;
  44:CDC.c         **** 	u8 	bDataBits;
  45:CDC.c         **** 	u8	lineState;
  46:CDC.c         **** } LineInfo;
  47:CDC.c         **** 
  48:CDC.c         **** static volatile LineInfo _usbLineInfo = { 57600, 0x00, 0x00, 0x00, 0x00 };
  49:CDC.c         **** 
  50:CDC.c         **** extern const CDCDescriptor _cdcInterface PROGMEM;
  51:CDC.c         **** const CDCDescriptor _cdcInterface =
  52:CDC.c         **** {
  53:CDC.c         **** 	D_IAD(0,2,CDC_COMMUNICATION_INTERFACE_CLASS,CDC_ABSTRACT_CONTROL_MODEL,1),
  54:CDC.c         **** 
  55:CDC.c         **** 	//	CDC communication interface
  56:CDC.c         **** 	D_INTERFACE(CDC_ACM_INTERFACE,1,CDC_COMMUNICATION_INTERFACE_CLASS,CDC_ABSTRACT_CONTROL_MODEL,0),
  57:CDC.c         **** 	D_CDCCS(CDC_HEADER,0x10,0x01),								// Header (1.10 bcd)
  58:CDC.c         **** 	D_CDCCS(CDC_CALL_MANAGEMENT,1,1),							// Device handles call management (not)
  59:CDC.c         **** 	D_CDCCS4(CDC_ABSTRACT_CONTROL_MANAGEMENT,6),				// SET_LINE_CODING, GET_LINE_CODING, SET_CONTROL_L
  60:CDC.c         **** 	D_CDCCS(CDC_UNION,CDC_ACM_INTERFACE,CDC_DATA_INTERFACE),	// Communication interface is master, dat
  61:CDC.c         **** 	D_ENDPOINT(USB_ENDPOINT_IN (CDC_ENDPOINT_ACM),USB_ENDPOINT_TYPE_INTERRUPT,0x10,0x40),
  62:CDC.c         **** 
  63:CDC.c         **** 	//	CDC data interface
  64:CDC.c         **** 	D_INTERFACE(CDC_DATA_INTERFACE,2,CDC_DATA_INTERFACE_CLASS,0,0),
  65:CDC.c         **** 	D_ENDPOINT(USB_ENDPOINT_OUT(CDC_ENDPOINT_OUT),USB_ENDPOINT_TYPE_BULK,0x40,0),
  66:CDC.c         **** 	D_ENDPOINT(USB_ENDPOINT_IN (CDC_ENDPOINT_IN ),USB_ENDPOINT_TYPE_BULK,0x40,0)
  67:CDC.c         **** };
  68:CDC.c         **** 
  69:CDC.c         **** int WEAK CDC_GetInterface(u8* interfaceNum)
  70:CDC.c         **** {
 155               		.stabn	68,0,70,.LM0-.LFBB1
 156               	.LM0:
 157               	.LFBB1:
 158               	/* prologue: function */
GAS LISTING /tmp/cc9TtpNu.s 			page 5


 159               	/* frame size = 0 */
 160               	/* stack size = 0 */
 161               	.L__stack_usage = 0
 162 0000 FC01      		movw r30,r24
  71:CDC.c         **** 	interfaceNum[0] += 2;	// uses 2
 163               		.stabn	68,0,71,.LM1-.LFBB1
 164               	.LM1:
 165 0002 9081      		ld r25,Z
 166 0004 9E5F      		subi r25,lo8(-(2))
 167 0006 9083      		st Z,r25
  72:CDC.c         **** 	return USB_SendControl(TRANSFER_PGM,&_cdcInterface,sizeof(_cdcInterface));
 168               		.stabn	68,0,72,.LM2-.LFBB1
 169               	.LM2:
 170 0008 42E4      		ldi r20,lo8(66)
 171 000a 50E0      		ldi r21,0
 172 000c 60E0      		ldi r22,lo8(_cdcInterface)
 173 000e 70E0      		ldi r23,hi8(_cdcInterface)
 174 0010 80E8      		ldi r24,lo8(-128)
 175 0012 0C94 0000 		jmp USB_SendControl
 176               		.size	CDC_GetInterface, .-CDC_GetInterface
 177               	.Lscope1:
 178               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 179               		.stabd	78,0,0
 180               		.section	.text.CDC_Setup,"ax",@progbits
 181               		.stabs	"CDC_Setup:F(2,5)",36,0,75,CDC_Setup
 182               		.stabs	"setup:P(0,58)=*(1,1)",64,0,75,30
 183               		.weak	CDC_Setup
 184               		.type	CDC_Setup, @function
 185               	CDC_Setup:
 186               		.stabd	46,0,0
  73:CDC.c         **** }
  74:CDC.c         **** 
  75:CDC.c         **** bool WEAK   CDC_Setup(Setup *setup)
  76:CDC.c         **** {
 187               		.stabn	68,0,76,.LM3-.LFBB2
 188               	.LM3:
 189               	.LFBB2:
 190               	/* prologue: function */
 191               	/* frame size = 0 */
 192               	/* stack size = 0 */
 193               	.L__stack_usage = 0
 194 0000 FC01      		movw r30,r24
  77:CDC.c         **** 	u8 r = setup->bRequest;
 195               		.stabn	68,0,77,.LM4-.LFBB2
 196               	.LM4:
 197 0002 8181      		ldd r24,Z+1
  78:CDC.c         **** 	u8 requestType = setup->bmRequestType;
 198               		.stabn	68,0,78,.LM5-.LFBB2
 199               	.LM5:
 200 0004 9081      		ld r25,Z
  79:CDC.c         **** 
  80:CDC.c         **** 	if (REQUEST_DEVICETOHOST_CLASS_INTERFACE == requestType)
 201               		.stabn	68,0,80,.LM6-.LFBB2
 202               	.LM6:
 203 0006 913A      		cpi r25,lo8(-95)
 204 0008 01F4      		brne .L3
  81:CDC.c         **** 	{
GAS LISTING /tmp/cc9TtpNu.s 			page 6


  82:CDC.c         **** 		if (CDC_GET_LINE_CODING == r)
 205               		.stabn	68,0,82,.LM7-.LFBB2
 206               	.LM7:
 207 000a 8132      		cpi r24,lo8(33)
 208 000c 01F0      		breq .+2
 209 000e 00C0      		rjmp .L9
  83:CDC.c         **** 		{
  84:CDC.c         **** 			USB_SendControl(0,(void*)&_usbLineInfo,7);
 210               		.stabn	68,0,84,.LM8-.LFBB2
 211               	.LM8:
 212 0010 47E0      		ldi r20,lo8(7)
 213 0012 50E0      		ldi r21,0
 214 0014 60E0      		ldi r22,lo8(_usbLineInfo)
 215 0016 70E0      		ldi r23,hi8(_usbLineInfo)
 216 0018 80E0      		ldi r24,0
 217 001a 0E94 0000 		call USB_SendControl
 218 001e 00C0      		rjmp .L10
 219               	.L3:
  85:CDC.c         **** 			return true;
  86:CDC.c         **** 		}
  87:CDC.c         **** 	}
  88:CDC.c         **** 
  89:CDC.c         **** 	if (REQUEST_HOSTTODEVICE_CLASS_INTERFACE == requestType)
 220               		.stabn	68,0,89,.LM9-.LFBB2
 221               	.LM9:
 222 0020 9132      		cpi r25,lo8(33)
 223 0022 01F0      		breq .+2
 224 0024 00C0      		rjmp .L9
  90:CDC.c         **** 	{
  91:CDC.c         **** 		if (CDC_SET_LINE_CODING == r)
 225               		.stabn	68,0,91,.LM10-.LFBB2
 226               	.LM10:
 227 0026 8032      		cpi r24,lo8(32)
 228 0028 01F4      		brne .L5
  92:CDC.c         **** 		{
  93:CDC.c         **** 			USB_RecvControl((void*)&_usbLineInfo,7);
 229               		.stabn	68,0,93,.LM11-.LFBB2
 230               	.LM11:
 231 002a 67E0      		ldi r22,lo8(7)
 232 002c 70E0      		ldi r23,0
 233 002e 80E0      		ldi r24,lo8(_usbLineInfo)
 234 0030 90E0      		ldi r25,hi8(_usbLineInfo)
 235 0032 0E94 0000 		call USB_RecvControl
 236 0036 00C0      		rjmp .L10
 237               	.L5:
  94:CDC.c         **** 			return true;
  95:CDC.c         **** 		}
  96:CDC.c         **** 
  97:CDC.c         **** 		if (CDC_SET_CONTROL_LINE_STATE == r)
 238               		.stabn	68,0,97,.LM12-.LFBB2
 239               	.LM12:
 240 0038 8232      		cpi r24,lo8(34)
 241 003a 01F0      		breq .+2
 242 003c 00C0      		rjmp .L9
  98:CDC.c         **** 		{
  99:CDC.c         **** 			_usbLineInfo.lineState = setup->wValueL;
 243               		.stabn	68,0,99,.LM13-.LFBB2
GAS LISTING /tmp/cc9TtpNu.s 			page 7


 244               	.LM13:
 245 003e 8281      		ldd r24,Z+2
 246 0040 8093 0000 		sts _usbLineInfo+7,r24
 100:CDC.c         **** 
 101:CDC.c         **** 			// auto-reset into the bootloader is triggered when the port, already 
 102:CDC.c         **** 			// open at 1200 bps, is closed.  this is the signal to start the watchdog
 103:CDC.c         **** 			// with a relatively long period so it can finish housekeeping tasks
 104:CDC.c         **** 			// like servicing endpoints before the sketch ends
 105:CDC.c         **** 			if (1200 == _usbLineInfo.dwDTERate) {
 247               		.stabn	68,0,105,.LM14-.LFBB2
 248               	.LM14:
 249 0044 8091 0000 		lds r24,_usbLineInfo
 250 0048 9091 0000 		lds r25,_usbLineInfo+1
 251 004c A091 0000 		lds r26,_usbLineInfo+2
 252 0050 B091 0000 		lds r27,_usbLineInfo+3
 253 0054 803B      		cpi r24,-80
 254 0056 9440      		sbci r25,4
 255 0058 A105      		cpc r26,__zero_reg__
 256 005a B105      		cpc r27,__zero_reg__
 257 005c 01F4      		brne .L10
 106:CDC.c         **** 				// We check DTR state to determine if host port is open (bit 0 of lineState).
 107:CDC.c         **** 				if ((_usbLineInfo.lineState & 0x01) == 0) {
 258               		.stabn	68,0,107,.LM15-.LFBB2
 259               	.LM15:
 260 005e 8091 0000 		lds r24,_usbLineInfo+7
 261 0062 80FD      		sbrc r24,0
 262 0064 00C0      		rjmp .L6
 108:CDC.c         **** 					*(uint16_t *)0x0800 = 0x7777;
 263               		.stabn	68,0,108,.LM16-.LFBB2
 264               	.LM16:
 265 0066 87E7      		ldi r24,lo8(119)
 266 0068 97E7      		ldi r25,lo8(119)
 267 006a 9093 0108 		sts 2048+1,r25
 268 006e 8093 0008 		sts 2048,r24
 269               	.LBB9:
 270               	.LBB10:
 271               		.stabs	"/usr/lib/avr/include/avr/wdt.h",132,0,0,.Ltext1
 272               	.Ltext1:
   1:/usr/lib/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/lib/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/lib/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/lib/avr/include/avr/wdt.h **** 
   5:/usr/lib/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/avr/wdt.h **** 
   8:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/avr/wdt.h **** 
  11:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/avr/include/avr/wdt.h ****      distribution.
  15:/usr/lib/avr/include/avr/wdt.h **** 
  16:/usr/lib/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/lib/avr/include/avr/wdt.h **** 
GAS LISTING /tmp/cc9TtpNu.s 			page 8


  20:/usr/lib/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/avr/include/avr/wdt.h **** 
  32:/usr/lib/avr/include/avr/wdt.h **** /* $Id$ */
  33:/usr/lib/avr/include/avr/wdt.h **** 
  34:/usr/lib/avr/include/avr/wdt.h **** /*
  35:/usr/lib/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/lib/avr/include/avr/wdt.h ****  */
  37:/usr/lib/avr/include/avr/wdt.h **** 
  38:/usr/lib/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/lib/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/lib/avr/include/avr/wdt.h **** 
  41:/usr/lib/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/lib/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/lib/avr/include/avr/wdt.h **** 
  44:/usr/lib/avr/include/avr/wdt.h **** /** \file */
  45:/usr/lib/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/lib/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/lib/avr/include/avr/wdt.h **** 
  48:/usr/lib/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/lib/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/lib/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/lib/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/lib/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/lib/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/lib/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/lib/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/lib/avr/include/avr/wdt.h **** 
  57:/usr/lib/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/lib/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/lib/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/lib/avr/include/avr/wdt.h **** 
  61:/usr/lib/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/lib/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/lib/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/lib/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/lib/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/lib/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/lib/avr/include/avr/wdt.h ****     the following:
  68:/usr/lib/avr/include/avr/wdt.h **** 
  69:/usr/lib/avr/include/avr/wdt.h ****     \code
  70:/usr/lib/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/lib/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/lib/avr/include/avr/wdt.h **** 
  73:/usr/lib/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/lib/avr/include/avr/wdt.h **** 
  75:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((naked)) \
GAS LISTING /tmp/cc9TtpNu.s 			page 9


  77:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/lib/avr/include/avr/wdt.h ****     {
  80:/usr/lib/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/lib/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/lib/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/lib/avr/include/avr/wdt.h ****     }
  84:/usr/lib/avr/include/avr/wdt.h ****     \endcode
  85:/usr/lib/avr/include/avr/wdt.h **** 
  86:/usr/lib/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/lib/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/lib/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/lib/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/lib/avr/include/avr/wdt.h **** */
  91:/usr/lib/avr/include/avr/wdt.h **** 
  92:/usr/lib/avr/include/avr/wdt.h **** /**
  93:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/lib/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/lib/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/lib/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/lib/avr/include/avr/wdt.h **** */
  98:/usr/lib/avr/include/avr/wdt.h **** 
  99:/usr/lib/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/lib/avr/include/avr/wdt.h **** 
 101:/usr/lib/avr/include/avr/wdt.h **** #ifndef __DOXYGEN__
 102:/usr/lib/avr/include/avr/wdt.h **** 
 103:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDP3)
 104:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 105:/usr/lib/avr/include/avr/wdt.h **** #else
 106:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 107:/usr/lib/avr/include/avr/wdt.h **** #endif
 108:/usr/lib/avr/include/avr/wdt.h **** 
 109:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 110:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 111:/usr/lib/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 112:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 113:/usr/lib/avr/include/avr/wdt.h **** #else
 114:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 115:/usr/lib/avr/include/avr/wdt.h **** #endif
 116:/usr/lib/avr/include/avr/wdt.h **** 
 117:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTOE)
 118:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 119:/usr/lib/avr/include/avr/wdt.h **** #else
 120:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 121:/usr/lib/avr/include/avr/wdt.h **** #endif
 122:/usr/lib/avr/include/avr/wdt.h **** 
 123:/usr/lib/avr/include/avr/wdt.h **** #endif	/* !__DOXYGEN__ */
 124:/usr/lib/avr/include/avr/wdt.h **** 
 125:/usr/lib/avr/include/avr/wdt.h **** 
 126:/usr/lib/avr/include/avr/wdt.h **** /**
 127:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 128:/usr/lib/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 129:/usr/lib/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 130:/usr/lib/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 131:/usr/lib/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 132:/usr/lib/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 133:/usr/lib/avr/include/avr/wdt.h **** 
GAS LISTING /tmp/cc9TtpNu.s 			page 10


 134:/usr/lib/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 135:/usr/lib/avr/include/avr/wdt.h **** */
 136:/usr/lib/avr/include/avr/wdt.h **** 
 137:/usr/lib/avr/include/avr/wdt.h **** 
 138:/usr/lib/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 139:/usr/lib/avr/include/avr/wdt.h **** 
 140:/usr/lib/avr/include/avr/wdt.h **** #if defined (WDT_CTRLA) && !defined(RAMPD)
 141:/usr/lib/avr/include/avr/wdt.h **** 
 142:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 143:/usr/lib/avr/include/avr/wdt.h **** do { \
 144:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 145:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 146:/usr/lib/avr/include/avr/wdt.h **** 	"wdr"									"\n\t" \
 147:/usr/lib/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]"		"\n\t" \
 148:/usr/lib/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"				"\n\t" \
 149:/usr/lib/avr/include/avr/wdt.h **** 	"sbr %[tmp], %[wdt_enable_timeout]"		"\n\t" \
 150:/usr/lib/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"				"\n\t" \
 151:/usr/lib/avr/include/avr/wdt.h **** 	"1:lds %[tmp], %[wdt_status_reg]"		"\n\t" \
 152:/usr/lib/avr/include/avr/wdt.h **** 	"sbrc %[tmp], %[wdt_syncbusy_bit]"		"\n\t" \
 153:/usr/lib/avr/include/avr/wdt.h **** 	"rjmp 1b"								"\n\t" \
 154:/usr/lib/avr/include/avr/wdt.h **** 	: [tmp]					"=r" (temp) \
 155:/usr/lib/avr/include/avr/wdt.h **** 	: [ccp_reg]				"I"  (_SFR_IO_ADDR(CCP)), \
 156:/usr/lib/avr/include/avr/wdt.h **** 	  [ioreg_cen_mask]		"r"  ((uint8_t)CCP_IOREG_gc), \
 157:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_reg]				"n"  (_SFR_MEM_ADDR(WDT_CTRLA)), \
 158:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_enable_timeout]	"M"  (timeout), \
 159:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_status_reg]		"n"  (_SFR_MEM_ADDR(WDT_STATUS)), \
 160:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_syncbusy_bit]	"I"  (WDT_SYNCBUSY_bm) \
 161:/usr/lib/avr/include/avr/wdt.h **** ); \
 162:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 163:/usr/lib/avr/include/avr/wdt.h **** 
 164:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 165:/usr/lib/avr/include/avr/wdt.h **** do { \
 166:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 167:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 168:/usr/lib/avr/include/avr/wdt.h **** 	"wdr"								"\n\t" \
 169:/usr/lib/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 170:/usr/lib/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"			"\n\t" \
 171:/usr/lib/avr/include/avr/wdt.h **** 	"cbr %[tmp], %[timeout_mask]"       "\n\t" \
 172:/usr/lib/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"			"\n\t" \
 173:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]            "=r" (temp) \
 174:/usr/lib/avr/include/avr/wdt.h ****     : [ccp_reg]        "I" (_SFR_IO_ADDR(CCP)),       \
 175:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask] "r" ((uint8_t)CCP_IOREG_gc),   \
 176:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]        "n" (_SFR_MEM_ADDR(WDT_CTRLA)),\
 177:/usr/lib/avr/include/avr/wdt.h ****       [timeout_mask]   "I" (WDT_PERIOD_gm) \
 178:/usr/lib/avr/include/avr/wdt.h **** ); \
 179:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 180:/usr/lib/avr/include/avr/wdt.h **** 
 181:/usr/lib/avr/include/avr/wdt.h **** #else // defined (WDT_CTRLA) && !defined(RAMPD)
 182:/usr/lib/avr/include/avr/wdt.h **** 
 183:/usr/lib/avr/include/avr/wdt.h **** /*
 184:/usr/lib/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 185:/usr/lib/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 186:/usr/lib/avr/include/avr/wdt.h ****    registers to the CCP register
 187:/usr/lib/avr/include/avr/wdt.h **** ** At the same time,
 188:/usr/lib/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 189:/usr/lib/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 190:/usr/lib/avr/include/avr/wdt.h ****    3) set timeout (timeout)
GAS LISTING /tmp/cc9TtpNu.s 			page 11


 191:/usr/lib/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 192:/usr/lib/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 193:/usr/lib/avr/include/avr/wdt.h ****    sync is finished).
 194:/usr/lib/avr/include/avr/wdt.h **** */
 195:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 196:/usr/lib/avr/include/avr/wdt.h **** do { \
 197:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 198:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 199:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 200:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 201:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 202:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 203:/usr/lib/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 204:/usr/lib/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 205:/usr/lib/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 206:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 207:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 208:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 209:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 210:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 211:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 212:/usr/lib/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 213:/usr/lib/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 214:/usr/lib/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 215:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 216:/usr/lib/avr/include/avr/wdt.h **** ); \
 217:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 218:/usr/lib/avr/include/avr/wdt.h **** 
 219:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 220:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 221:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 222:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 223:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 224:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 225:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 226:/usr/lib/avr/include/avr/wdt.h ****     : \
 227:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 228:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 229:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 230:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 231:/usr/lib/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 232:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 233:/usr/lib/avr/include/avr/wdt.h **** );
 234:/usr/lib/avr/include/avr/wdt.h **** 
 235:/usr/lib/avr/include/avr/wdt.h **** #endif // defined (WDT_CTRLA) && !defined(RAMPD)
 236:/usr/lib/avr/include/avr/wdt.h **** 
 237:/usr/lib/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 238:/usr/lib/avr/include/avr/wdt.h **** 
 239:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 240:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 241:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 242:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 243:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 244:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 245:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 246:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 247:/usr/lib/avr/include/avr/wdt.h ****     : /* no outputs */  \
GAS LISTING /tmp/cc9TtpNu.s 			page 12


 248:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 249:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 250:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 251:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 252:/usr/lib/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 253:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 254:/usr/lib/avr/include/avr/wdt.h **** )
 255:/usr/lib/avr/include/avr/wdt.h **** 
 256:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 257:/usr/lib/avr/include/avr/wdt.h **** do { \
 258:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 259:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 260:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 261:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 262:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 263:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 264:/usr/lib/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 265:/usr/lib/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 266:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 267:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 268:/usr/lib/avr/include/avr/wdt.h ****     : /*no output */ \
 269:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 270:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 271:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 272:/usr/lib/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 273:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 274:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 275:/usr/lib/avr/include/avr/wdt.h **** ); \
 276:/usr/lib/avr/include/avr/wdt.h **** }while(0)
 277:/usr/lib/avr/include/avr/wdt.h **** 
 278:/usr/lib/avr/include/avr/wdt.h **** #elif defined(CCP)
 279:/usr/lib/avr/include/avr/wdt.h **** 
 280:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 281:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 282:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 283:/usr/lib/avr/include/avr/wdt.h **** {
 284:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 285:/usr/lib/avr/include/avr/wdt.h **** 	{
 286:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 287:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 288:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 289:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 290:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 291:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 292:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 293:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 294:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 295:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 296:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 297:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 298:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 299:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 300:/usr/lib/avr/include/avr/wdt.h **** 			);
 301:/usr/lib/avr/include/avr/wdt.h **** 	}
 302:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 303:/usr/lib/avr/include/avr/wdt.h **** 	{
 304:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
GAS LISTING /tmp/cc9TtpNu.s 			page 13


 305:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 306:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 307:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 308:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 309:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 310:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 311:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 312:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 313:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 314:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 315:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 316:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 317:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 318:/usr/lib/avr/include/avr/wdt.h **** 			);
 319:/usr/lib/avr/include/avr/wdt.h **** 	}
 320:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 321:/usr/lib/avr/include/avr/wdt.h **** 	{
 322:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 323:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 324:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 325:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 326:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 327:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 328:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 329:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 330:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 331:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 332:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 333:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 334:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 335:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 336:/usr/lib/avr/include/avr/wdt.h **** 			);
 337:/usr/lib/avr/include/avr/wdt.h **** 	}
 338:/usr/lib/avr/include/avr/wdt.h **** 	else
 339:/usr/lib/avr/include/avr/wdt.h ****  	{
 340:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 341:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 342:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 343:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 344:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 345:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 346:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 347:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 348:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 349:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 350:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 351:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 352:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 353:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 354:/usr/lib/avr/include/avr/wdt.h **** 			);
 355:/usr/lib/avr/include/avr/wdt.h **** 	}
 356:/usr/lib/avr/include/avr/wdt.h **** }
 357:/usr/lib/avr/include/avr/wdt.h **** 
 358:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 359:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 360:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 361:/usr/lib/avr/include/avr/wdt.h **** {
GAS LISTING /tmp/cc9TtpNu.s 			page 14


 362:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 363:/usr/lib/avr/include/avr/wdt.h **** 	{
 364:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 365:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 366:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 367:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 368:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 369:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 370:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 371:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 372:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 373:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 374:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 375:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 376:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 377:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 378:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 379:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 380:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 381:/usr/lib/avr/include/avr/wdt.h **** 				);
 382:/usr/lib/avr/include/avr/wdt.h **** 	}
 383:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 384:/usr/lib/avr/include/avr/wdt.h **** 	{
 385:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 386:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 387:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 388:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 389:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 390:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 391:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 392:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 393:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 394:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 395:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 396:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 397:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 398:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 399:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 400:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 401:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 402:/usr/lib/avr/include/avr/wdt.h **** 				);
 403:/usr/lib/avr/include/avr/wdt.h **** 	}
 404:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 405:/usr/lib/avr/include/avr/wdt.h **** 	{
 406:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 407:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 408:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 409:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 410:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 411:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 412:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 413:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 414:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 415:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 416:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 417:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 418:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
GAS LISTING /tmp/cc9TtpNu.s 			page 15


 419:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 420:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 421:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 422:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 423:/usr/lib/avr/include/avr/wdt.h **** 				);
 424:/usr/lib/avr/include/avr/wdt.h **** 	}
 425:/usr/lib/avr/include/avr/wdt.h **** 	else
 426:/usr/lib/avr/include/avr/wdt.h **** 	{
 427:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 428:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 429:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 430:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 431:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 432:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 433:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 434:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 435:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 436:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 437:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 438:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 439:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 440:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 441:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 442:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 443:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 444:/usr/lib/avr/include/avr/wdt.h **** 				);
 445:/usr/lib/avr/include/avr/wdt.h **** 	}
 446:/usr/lib/avr/include/avr/wdt.h **** }
 447:/usr/lib/avr/include/avr/wdt.h **** 
 448:/usr/lib/avr/include/avr/wdt.h **** #else
 449:/usr/lib/avr/include/avr/wdt.h **** 
 450:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 451:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 452:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 453:/usr/lib/avr/include/avr/wdt.h **** {
 454:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 455:/usr/lib/avr/include/avr/wdt.h **** 	{
 456:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 457:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 458:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 459:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 460:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 461:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 462:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 463:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 464:/usr/lib/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 465:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 466:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 467:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 468:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 469:/usr/lib/avr/include/avr/wdt.h **** 		);
 470:/usr/lib/avr/include/avr/wdt.h **** 	}
 471:/usr/lib/avr/include/avr/wdt.h **** 	else
 472:/usr/lib/avr/include/avr/wdt.h **** 	{
 473:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 273               		.stabn	68,0,473,.LM17-.LFBB2
 274               	.LM17:
GAS LISTING /tmp/cc9TtpNu.s 			page 16


 275 0072 9BE0      		ldi r25,lo8(11)
 276 0074 88E1      		ldi r24,lo8(24)
 277               	/* #APP */
 278               	 ;  473 "/usr/lib/avr/include/avr/wdt.h" 1
 279 0076 0FB6      		in __tmp_reg__,__SREG__
 280 0078 F894      		cli
 281 007a A895      		wdr
 282 007c 8093 6000 		sts 96, r24
 283 0080 0FBE      		out __SREG__,__tmp_reg__
 284 0082 9093 6000 		sts 96, r25
 285               	 	
 286               	 ;  0 "" 2
 287               	/* #NOAPP */
 288 0086 00C0      		rjmp .L10
 289               	.L6:
 290               	.LBE10:
 291               	.LBE9:
 292               	.LBB11:
 293               	.LBB12:
 474:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 475:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 476:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 477:/usr/lib/avr/include/avr/wdt.h **** 				"sts %0, %1" "\n\t"
 478:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 479:/usr/lib/avr/include/avr/wdt.h **** 				"sts %0, %2" "\n \t"
 480:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 481:/usr/lib/avr/include/avr/wdt.h **** 				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 482:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 483:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 484:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 485:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 486:/usr/lib/avr/include/avr/wdt.h **** 		);
 487:/usr/lib/avr/include/avr/wdt.h **** 	}
 488:/usr/lib/avr/include/avr/wdt.h **** }
 489:/usr/lib/avr/include/avr/wdt.h **** 
 490:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 491:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 492:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 493:/usr/lib/avr/include/avr/wdt.h **** {
 494:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 495:/usr/lib/avr/include/avr/wdt.h **** 	{
 496:/usr/lib/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 497:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 498:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__"    "\n\t"
 499:/usr/lib/avr/include/avr/wdt.h **** 				"cli"                        "\n\t"
 500:/usr/lib/avr/include/avr/wdt.h **** 				"wdr"                        "\n\t"
 501:/usr/lib/avr/include/avr/wdt.h **** 				"in  %[TEMPREG],%[WDTREG]"   "\n\t"
 502:/usr/lib/avr/include/avr/wdt.h **** 				"ori %[TEMPREG],%[WDCE_WDE]" "\n\t"
 503:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMPREG]"   "\n\t"
 504:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],__zero_reg__" "\n\t"
 505:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__"   "\n\t"
 506:/usr/lib/avr/include/avr/wdt.h **** 				: [TEMPREG] "=d" (temp_reg)
 507:/usr/lib/avr/include/avr/wdt.h **** 				: [WDTREG]  "I"  (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 508:/usr/lib/avr/include/avr/wdt.h **** 				[WDCE_WDE]  "n"  ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE)))
 509:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 510:/usr/lib/avr/include/avr/wdt.h **** 		);
 511:/usr/lib/avr/include/avr/wdt.h **** 	}
GAS LISTING /tmp/cc9TtpNu.s 			page 17


 512:/usr/lib/avr/include/avr/wdt.h **** 	else
 513:/usr/lib/avr/include/avr/wdt.h **** 	{
 514:/usr/lib/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 515:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 294               		.stabn	68,0,515,.LM18-.LFBB2
 295               	.LM18:
 296               	/* #APP */
 297               	 ;  515 "/usr/lib/avr/include/avr/wdt.h" 1
 298 0088 0FB6      		in __tmp_reg__,__SREG__
 299 008a F894      		cli
 300 008c A895      		wdr
 301 008e 8091 6000 		lds r24,96
 302 0092 8861      		ori r24,24
 303 0094 8093 6000 		sts 96,r24
 304 0098 1092 6000 		sts 96,__zero_reg__
 305 009c 0FBE      		out __SREG__,__tmp_reg__
 306               		
 307               	 ;  0 "" 2
 308               	/* #NOAPP */
 309               	.LBE12:
 310               	.LBE11:
 311               		.stabs	"CDC.c",132,0,0,.Ltext2
 312               	.Ltext2:
 109:CDC.c         **** 					wdt_enable(WDTO_120MS);
 110:CDC.c         **** 				} else {
 111:CDC.c         **** 					// Most OSs do some intermediate steps when configuring ports and DTR can
 112:CDC.c         **** 					// twiggle more than once before stabilizing.
 113:CDC.c         **** 					// To avoid spurious resets we set the watchdog to 250ms and eventually
 114:CDC.c         **** 					// cancel if DTR goes back high.
 115:CDC.c         **** 	
 116:CDC.c         **** 					wdt_disable();
 117:CDC.c         **** 					wdt_reset();
 313               		.stabn	68,0,117,.LM19-.LFBB2
 314               	.LM19:
 315               	/* #APP */
 316               	 ;  117 "CDC.c" 1
 317 009e A895      		wdr
 318               	 ;  0 "" 2
 118:CDC.c         **** 					*(uint16_t *)0x0800 = 0x0;
 319               		.stabn	68,0,118,.LM20-.LFBB2
 320               	.LM20:
 321               	/* #NOAPP */
 322 00a0 1092 0108 		sts 2048+1,__zero_reg__
 323 00a4 1092 0008 		sts 2048,__zero_reg__
 324 00a8 00C0      		rjmp .L10
 325               	.L9:
 119:CDC.c         **** 				}
 120:CDC.c         **** 			}
 121:CDC.c         **** 			return true;
 122:CDC.c         **** 		}
 123:CDC.c         **** 	}
 124:CDC.c         **** 	return false;
 326               		.stabn	68,0,124,.LM21-.LFBB2
 327               	.LM21:
 328 00aa 80E0      		ldi r24,0
 329 00ac 0895      		ret
 330               	.L10:
GAS LISTING /tmp/cc9TtpNu.s 			page 18


 121:CDC.c         **** 		}
 331               		.stabn	68,0,121,.LM22-.LFBB2
 332               	.LM22:
 333 00ae 81E0      		ldi r24,lo8(1)
 125:CDC.c         **** }
 334               		.stabn	68,0,125,.LM23-.LFBB2
 335               	.LM23:
 336 00b0 0895      		ret
 337               		.size	CDC_Setup, .-CDC_Setup
 338               		.stabs	"r:r(2,1)",64,0,77,24
 339               		.stabs	"requestType:r(2,1)",64,0,78,25
 340               		.stabn	192,0,0,.LFBB2-.LFBB2
 341               		.stabn	224,0,0,.Lscope2-.LFBB2
 342               	.Lscope2:
 343               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 344               		.stabd	78,0,0
 345               		.section	.text.Serial_begin,"ax",@progbits
 346               		.stabs	"Serial_begin:F(0,49)",36,0,130,Serial_begin
 347               		.stabs	"baud_count:P(9,4)",64,0,130,24
 348               	.global	Serial_begin
 349               		.type	Serial_begin, @function
 350               	Serial_begin:
 351               		.stabd	46,0,0
 126:CDC.c         **** 
 127:CDC.c         **** 
 128:CDC.c         **** int _serial_Peek = -1;
 129:CDC.c         **** 
 130:CDC.c         **** void Serial_begin(uint16_t baud_count)
 131:CDC.c         **** {
 352               		.stabn	68,0,131,.LM24-.LFBB3
 353               	.LM24:
 354               	.LFBB3:
 355               	/* prologue: function */
 356               	/* frame size = 0 */
 357               	/* stack size = 0 */
 358               	.L__stack_usage = 0
 359 0000 0895      		ret
 360               		.size	Serial_begin, .-Serial_begin
 361               	.Lscope3:
 362               		.stabs	"",36,0,0,.Lscope3-.LFBB3
 363               		.stabd	78,0,0
 364               		.section	.text.Serial_end,"ax",@progbits
 365               		.stabs	"Serial_end:F(0,49)",36,0,134,Serial_end
 366               	.global	Serial_end
 367               		.type	Serial_end, @function
 368               	Serial_end:
 369               		.stabd	46,0,0
 132:CDC.c         **** }
 133:CDC.c         **** 
 134:CDC.c         **** void Serial_end(void)
 135:CDC.c         **** {
 370               		.stabn	68,0,135,.LM25-.LFBB4
 371               	.LM25:
 372               	.LFBB4:
 373               	/* prologue: function */
 374               	/* frame size = 0 */
 375               	/* stack size = 0 */
GAS LISTING /tmp/cc9TtpNu.s 			page 19


 376               	.L__stack_usage = 0
 377 0000 0895      		ret
 378               		.size	Serial_end, .-Serial_end
 379               	.Lscope4:
 380               		.stabs	"",36,0,0,.Lscope4-.LFBB4
 381               		.stabd	78,0,0
 382               		.section	.text.Serial_accept,"ax",@progbits
 383               		.stabs	"Serial_accept:F(0,49)",36,0,138,Serial_accept
 384               	.global	Serial_accept
 385               		.type	Serial_accept, @function
 386               	Serial_accept:
 387               		.stabd	46,0,0
 136:CDC.c         **** }
 137:CDC.c         **** 
 138:CDC.c         **** void Serial_accept(void) 
 139:CDC.c         **** {
 388               		.stabn	68,0,139,.LM26-.LFBB5
 389               	.LM26:
 390               	.LFBB5:
 391               	/* prologue: function */
 392               	/* frame size = 0 */
 393               	/* stack size = 0 */
 394               	.L__stack_usage = 0
 140:CDC.c         **** 	ring_buffer *buffer = &cdc_rx_buffer;
 141:CDC.c         **** 	int c = USB_RecvNB(CDC_RX); 
 395               		.stabn	68,0,141,.LM27-.LFBB5
 396               	.LM27:
 397 0000 82E0      		ldi r24,lo8(2)
 398 0002 0E94 0000 		call USB_RecvNB
 142:CDC.c         **** 	int i = (unsigned int)(buffer->head+1) % SERIAL_BUFFER_SIZE;
 399               		.stabn	68,0,142,.LM28-.LFBB5
 400               	.LM28:
 401 0006 2091 0000 		lds r18,cdc_rx_buffer+64
 402 000a 3091 0000 		lds r19,cdc_rx_buffer+64+1
 403 000e 2F5F      		subi r18,-1
 404 0010 3F4F      		sbci r19,-1
 405 0012 2F73      		andi r18,63
 406 0014 3327      		clr r19
 143:CDC.c         **** 	
 144:CDC.c         **** 	// if we should be storing the received character into the location
 145:CDC.c         **** 	// just before the tail (meaning that the head would advance to the
 146:CDC.c         **** 	// current location of the tail), we're about to overflow the buffer
 147:CDC.c         **** 	// and so we don't write the character or advance the head.
 148:CDC.c         **** 	if (i != buffer->tail) {
 407               		.stabn	68,0,148,.LM29-.LFBB5
 408               	.LM29:
 409 0016 4091 0000 		lds r20,cdc_rx_buffer+66
 410 001a 5091 0000 		lds r21,cdc_rx_buffer+66+1
 411 001e 2417      		cp r18,r20
 412 0020 3507      		cpc r19,r21
 413 0022 01F0      		breq .L14
 149:CDC.c         **** 		buffer->buffer[buffer->head] = c;
 414               		.stabn	68,0,149,.LM30-.LFBB5
 415               	.LM30:
 416 0024 E091 0000 		lds r30,cdc_rx_buffer+64
 417 0028 F091 0000 		lds r31,cdc_rx_buffer+64+1
 418 002c E050      		subi r30,lo8(-(cdc_rx_buffer))
GAS LISTING /tmp/cc9TtpNu.s 			page 20


 419 002e F040      		sbci r31,hi8(-(cdc_rx_buffer))
 420 0030 8083      		st Z,r24
 150:CDC.c         **** 		buffer->head = i;
 421               		.stabn	68,0,150,.LM31-.LFBB5
 422               	.LM31:
 423 0032 3093 0000 		sts cdc_rx_buffer+64+1,r19
 424 0036 2093 0000 		sts cdc_rx_buffer+64,r18
 425               	.L14:
 426 003a 0895      		ret
 427               		.size	Serial_accept, .-Serial_accept
 428               		.stabs	"i:r(0,1)",64,0,142,18
 429               		.stabn	192,0,0,.LFBB5-.LFBB5
 430               		.stabn	224,0,0,.Lscope5-.LFBB5
 431               	.Lscope5:
 432               		.stabs	"",36,0,0,.Lscope5-.LFBB5
 433               		.stabd	78,0,0
 434               		.section	.text.Serial_available,"ax",@progbits
 435               		.stabs	"Serial_available:F(0,1)",36,0,154,Serial_available
 436               	.global	Serial_available
 437               		.type	Serial_available, @function
 438               	Serial_available:
 439               		.stabd	46,0,0
 151:CDC.c         **** 	}
 152:CDC.c         **** }
 153:CDC.c         **** 
 154:CDC.c         **** int Serial_available(void)
 155:CDC.c         **** {
 440               		.stabn	68,0,155,.LM32-.LFBB6
 441               	.LM32:
 442               	.LFBB6:
 443               	/* prologue: function */
 444               	/* frame size = 0 */
 445               	/* stack size = 0 */
 446               	.L__stack_usage = 0
 156:CDC.c         **** 	ring_buffer *buffer = &cdc_rx_buffer;
 157:CDC.c         **** 	return (unsigned int)(SERIAL_BUFFER_SIZE + buffer->head - buffer->tail) % SERIAL_BUFFER_SIZE;
 447               		.stabn	68,0,157,.LM33-.LFBB6
 448               	.LM33:
 449 0000 8091 0000 		lds r24,cdc_rx_buffer+64
 450 0004 9091 0000 		lds r25,cdc_rx_buffer+64+1
 451 0008 2091 0000 		lds r18,cdc_rx_buffer+66
 452 000c 3091 0000 		lds r19,cdc_rx_buffer+66+1
 453 0010 821B      		sub r24,r18
 454 0012 930B      		sbc r25,r19
 158:CDC.c         **** }
 455               		.stabn	68,0,158,.LM34-.LFBB6
 456               	.LM34:
 457 0014 8F73      		andi r24,63
 458 0016 9927      		clr r25
 459 0018 0895      		ret
 460               		.size	Serial_available, .-Serial_available
 461               	.Lscope6:
 462               		.stabs	"",36,0,0,.Lscope6-.LFBB6
 463               		.stabd	78,0,0
 464               		.section	.text.Serial_peek,"ax",@progbits
 465               		.stabs	"Serial_peek:F(0,1)",36,0,160,Serial_peek
 466               	.global	Serial_peek
GAS LISTING /tmp/cc9TtpNu.s 			page 21


 467               		.type	Serial_peek, @function
 468               	Serial_peek:
 469               		.stabd	46,0,0
 159:CDC.c         **** 
 160:CDC.c         **** int Serial_peek(void)
 161:CDC.c         **** {
 470               		.stabn	68,0,161,.LM35-.LFBB7
 471               	.LM35:
 472               	.LFBB7:
 473               	/* prologue: function */
 474               	/* frame size = 0 */
 475               	/* stack size = 0 */
 476               	.L__stack_usage = 0
 162:CDC.c         **** 	ring_buffer *buffer = &cdc_rx_buffer;
 163:CDC.c         **** 	if (buffer->head == buffer->tail) {
 477               		.stabn	68,0,163,.LM36-.LFBB7
 478               	.LM36:
 479 0000 2091 0000 		lds r18,cdc_rx_buffer+64
 480 0004 3091 0000 		lds r19,cdc_rx_buffer+64+1
 481 0008 8091 0000 		lds r24,cdc_rx_buffer+66
 482 000c 9091 0000 		lds r25,cdc_rx_buffer+66+1
 483 0010 2817      		cp r18,r24
 484 0012 3907      		cpc r19,r25
 485 0014 01F0      		breq .L19
 164:CDC.c         **** 		return -1;
 165:CDC.c         **** 	} else {
 166:CDC.c         **** 		return buffer->buffer[buffer->tail];
 486               		.stabn	68,0,166,.LM37-.LFBB7
 487               	.LM37:
 488 0016 E091 0000 		lds r30,cdc_rx_buffer+66
 489 001a F091 0000 		lds r31,cdc_rx_buffer+66+1
 490 001e E050      		subi r30,lo8(-(cdc_rx_buffer))
 491 0020 F040      		sbci r31,hi8(-(cdc_rx_buffer))
 492 0022 8081      		ld r24,Z
 493 0024 90E0      		ldi r25,0
 494 0026 0895      		ret
 495               	.L19:
 164:CDC.c         **** 		return -1;
 496               		.stabn	68,0,164,.LM38-.LFBB7
 497               	.LM38:
 498 0028 8FEF      		ldi r24,lo8(-1)
 499 002a 9FEF      		ldi r25,lo8(-1)
 167:CDC.c         **** 	}
 168:CDC.c         **** }
 500               		.stabn	68,0,168,.LM39-.LFBB7
 501               	.LM39:
 502 002c 0895      		ret
 503               		.size	Serial_peek, .-Serial_peek
 504               	.Lscope7:
 505               		.stabs	"",36,0,0,.Lscope7-.LFBB7
 506               		.stabd	78,0,0
 507               		.section	.text.Serial_read,"ax",@progbits
 508               		.stabs	"Serial_read:F(0,1)",36,0,170,Serial_read
 509               	.global	Serial_read
 510               		.type	Serial_read, @function
 511               	Serial_read:
 512               		.stabd	46,0,0
GAS LISTING /tmp/cc9TtpNu.s 			page 22


 169:CDC.c         **** 
 170:CDC.c         **** int Serial_read(void)
 171:CDC.c         **** {
 513               		.stabn	68,0,171,.LM40-.LFBB8
 514               	.LM40:
 515               	.LFBB8:
 516               	/* prologue: function */
 517               	/* frame size = 0 */
 518               	/* stack size = 0 */
 519               	.L__stack_usage = 0
 172:CDC.c         **** 	ring_buffer *buffer = &cdc_rx_buffer;
 173:CDC.c         **** 	// if the head isn't ahead of the tail, we don't have any characters
 174:CDC.c         **** 	if (buffer->head == buffer->tail) {
 520               		.stabn	68,0,174,.LM41-.LFBB8
 521               	.LM41:
 522 0000 2091 0000 		lds r18,cdc_rx_buffer+64
 523 0004 3091 0000 		lds r19,cdc_rx_buffer+64+1
 524 0008 8091 0000 		lds r24,cdc_rx_buffer+66
 525 000c 9091 0000 		lds r25,cdc_rx_buffer+66+1
 526 0010 2817      		cp r18,r24
 527 0012 3907      		cpc r19,r25
 528 0014 01F0      		breq .L22
 529               	.LBB13:
 175:CDC.c         **** 		return -1;
 176:CDC.c         **** 	} else {
 177:CDC.c         **** 		unsigned char c = buffer->buffer[buffer->tail];
 530               		.stabn	68,0,177,.LM42-.LFBB8
 531               	.LM42:
 532 0016 E091 0000 		lds r30,cdc_rx_buffer+66
 533 001a F091 0000 		lds r31,cdc_rx_buffer+66+1
 534 001e E050      		subi r30,lo8(-(cdc_rx_buffer))
 535 0020 F040      		sbci r31,hi8(-(cdc_rx_buffer))
 536 0022 8081      		ld r24,Z
 178:CDC.c         **** 		buffer->tail = (unsigned int)(buffer->tail + 1) % SERIAL_BUFFER_SIZE;
 537               		.stabn	68,0,178,.LM43-.LFBB8
 538               	.LM43:
 539 0024 2091 0000 		lds r18,cdc_rx_buffer+66
 540 0028 3091 0000 		lds r19,cdc_rx_buffer+66+1
 541 002c 2F5F      		subi r18,-1
 542 002e 3F4F      		sbci r19,-1
 543 0030 2F73      		andi r18,63
 544 0032 3327      		clr r19
 545 0034 3093 0000 		sts cdc_rx_buffer+66+1,r19
 546 0038 2093 0000 		sts cdc_rx_buffer+66,r18
 179:CDC.c         **** 		return c;
 547               		.stabn	68,0,179,.LM44-.LFBB8
 548               	.LM44:
 549 003c 90E0      		ldi r25,0
 550 003e 0895      		ret
 551               	.L22:
 552               	.LBE13:
 175:CDC.c         **** 		return -1;
 553               		.stabn	68,0,175,.LM45-.LFBB8
 554               	.LM45:
 555 0040 8FEF      		ldi r24,lo8(-1)
 556 0042 9FEF      		ldi r25,lo8(-1)
 180:CDC.c         **** 	}	
GAS LISTING /tmp/cc9TtpNu.s 			page 23


 181:CDC.c         **** }
 557               		.stabn	68,0,181,.LM46-.LFBB8
 558               	.LM46:
 559 0044 0895      		ret
 560               		.size	Serial_read, .-Serial_read
 561               		.stabs	"c:r(0,13)",64,0,177,24
 562               		.stabn	192,0,0,.LBB13-.LFBB8
 563               		.stabn	224,0,0,.LBE13-.LFBB8
 564               	.Lscope8:
 565               		.stabs	"",36,0,0,.Lscope8-.LFBB8
 566               		.stabd	78,0,0
 567               		.section	.text.Serial_flush,"ax",@progbits
 568               		.stabs	"Serial_flush:F(0,49)",36,0,183,Serial_flush
 569               	.global	Serial_flush
 570               		.type	Serial_flush, @function
 571               	Serial_flush:
 572               		.stabd	46,0,0
 182:CDC.c         **** 
 183:CDC.c         **** void Serial_flush(void)
 184:CDC.c         **** {
 573               		.stabn	68,0,184,.LM47-.LFBB9
 574               	.LM47:
 575               	.LFBB9:
 576               	/* prologue: function */
 577               	/* frame size = 0 */
 578               	/* stack size = 0 */
 579               	.L__stack_usage = 0
 185:CDC.c         **** 	USB_Flush(CDC_TX);
 580               		.stabn	68,0,185,.LM48-.LFBB9
 581               	.LM48:
 582 0000 83E0      		ldi r24,lo8(3)
 583 0002 0C94 0000 		jmp USB_Flush
 584               		.size	Serial_flush, .-Serial_flush
 585               	.Lscope9:
 586               		.stabs	"",36,0,0,.Lscope9-.LFBB9
 587               		.stabd	78,0,0
 588               		.section	.text.Serial_write,"ax",@progbits
 589               		.stabs	"Serial_write:F(4,1)",36,0,188,Serial_write
 590               		.stabs	"c:p(9,2)",160,0,188,1
 591               	.global	Serial_write
 592               		.type	Serial_write, @function
 593               	Serial_write:
 594               		.stabd	46,0,0
 186:CDC.c         **** }
 187:CDC.c         **** 
 188:CDC.c         **** size_t Serial_write(uint8_t c)
 189:CDC.c         **** {
 595               		.stabn	68,0,189,.LM49-.LFBB10
 596               	.LM49:
 597               	.LFBB10:
 598 0000 CF93      		push r28
 599 0002 DF93      		push r29
 600 0004 1F92      		push __zero_reg__
 601 0006 CDB7      		in r28,__SP_L__
 602 0008 DEB7      		in r29,__SP_H__
 603               	/* prologue: function */
 604               	/* frame size = 1 */
GAS LISTING /tmp/cc9TtpNu.s 			page 24


 605               	/* stack size = 3 */
 606               	.L__stack_usage = 3
 607 000a 8983      		std Y+1,r24
 190:CDC.c         **** 	/* only try to send bytes if the high-level CDC connection itself 
 191:CDC.c         **** 	 is open (not just the pipe) - the OS should set lineState when the port
 192:CDC.c         **** 	 is opened and clear lineState when the port is closed.
 193:CDC.c         **** 	 bytes sent before the user opens the connection or after
 194:CDC.c         **** 	 the connection is closed are lost - just like with a UART. */
 195:CDC.c         **** 	
 196:CDC.c         **** 	// TODO - ZE - check behavior on different OSes and test what happens if an
 197:CDC.c         **** 	// open connection isn't broken cleanly (cable is yanked out, host dies
 198:CDC.c         **** 	// or locks up, or host virtual serial port hangs)
 199:CDC.c         **** 	if (_usbLineInfo.lineState > 0)	{
 608               		.stabn	68,0,199,.LM50-.LFBB10
 609               	.LM50:
 610 000c 8091 0000 		lds r24,_usbLineInfo+7
 611 0010 8111      		cpse r24,__zero_reg__
 612 0012 00C0      		rjmp .L25
 613               	.L27:
 200:CDC.c         **** 		int r = USB_Send(CDC_TX,&c,1);
 201:CDC.c         **** 		if (r > 0) {
 202:CDC.c         **** 			return r;
 203:CDC.c         **** 		} else {
 204:CDC.c         **** 			return 0;
 205:CDC.c         **** 		}
 206:CDC.c         **** 	}
 207:CDC.c         **** 	return 0;
 614               		.stabn	68,0,207,.LM51-.LFBB10
 615               	.LM51:
 616 0014 80E0      		ldi r24,0
 617 0016 90E0      		ldi r25,0
 618 0018 00C0      		rjmp .L26
 619               	.L25:
 620               	.LBB14:
 200:CDC.c         **** 		int r = USB_Send(CDC_TX,&c,1);
 621               		.stabn	68,0,200,.LM52-.LFBB10
 622               	.LM52:
 623 001a 41E0      		ldi r20,lo8(1)
 624 001c 50E0      		ldi r21,0
 625 001e BE01      		movw r22,r28
 626 0020 6F5F      		subi r22,-1
 627 0022 7F4F      		sbci r23,-1
 628 0024 83E0      		ldi r24,lo8(3)
 629 0026 0E94 0000 		call USB_Send
 201:CDC.c         **** 			return r;
 630               		.stabn	68,0,201,.LM53-.LFBB10
 631               	.LM53:
 632 002a 1816      		cp __zero_reg__,r24
 633 002c 1906      		cpc __zero_reg__,r25
 634 002e 04F4      		brge .L27
 635               	.L26:
 636               	/* epilogue start */
 637               	.LBE14:
 208:CDC.c         **** }
 638               		.stabn	68,0,208,.LM54-.LFBB10
 639               	.LM54:
 640 0030 0F90      		pop __tmp_reg__
GAS LISTING /tmp/cc9TtpNu.s 			page 25


 641 0032 DF91      		pop r29
 642 0034 CF91      		pop r28
 643 0036 0895      		ret
 644               		.size	Serial_write, .-Serial_write
 645               		.stabs	"r:r(0,1)",64,0,200,24
 646               		.stabn	192,0,0,.LBB14-.LFBB10
 647               		.stabn	224,0,0,.LBE14-.LFBB10
 648               	.Lscope10:
 649               		.stabs	"",36,0,0,.Lscope10-.LFBB10
 650               		.stabd	78,0,0
 651               		.section	.text.Serial_test,"ax",@progbits
 652               		.stabs	"Serial_test:F(2,1)",36,0,217,Serial_test
 653               	.global	Serial_test
 654               		.type	Serial_test, @function
 655               	Serial_test:
 656               		.stabd	46,0,0
 209:CDC.c         **** 
 210:CDC.c         **** // This operator is a convenient way for a sketch to check whether the
 211:CDC.c         **** // port has actually been configured and opened by the host (as opposed
 212:CDC.c         **** // to just being connected to the host).  It can be used, for example, in 
 213:CDC.c         **** // setup() before printing to ensure that an application on the host is
 214:CDC.c         **** // actually ready to receive and display the data.
 215:CDC.c         **** // We add a short delay before returning to fix a bug observed by Federico
 216:CDC.c         **** // where the port is configured (lineState != 0) but not quite opened.
 217:CDC.c         **** u8 Serial_test() {
 657               		.stabn	68,0,217,.LM55-.LFBB11
 658               	.LM55:
 659               	.LFBB11:
 660               	/* prologue: function */
 661               	/* frame size = 0 */
 662               	/* stack size = 0 */
 663               	.L__stack_usage = 0
 218:CDC.c         **** 	bool result = false;
 219:CDC.c         **** 	if (_usbLineInfo.lineState > 0) 
 664               		.stabn	68,0,219,.LM56-.LFBB11
 665               	.LM56:
 666 0000 9091 0000 		lds r25,_usbLineInfo+7
 667               	.LBB15:
 668               	.LBB16:
 669               		.stabs	"/usr/lib/avr/include/util/delay.h",132,0,0,.Ltext3
 670               	.Ltext3:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
GAS LISTING /tmp/cc9TtpNu.s 			page 26


  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
GAS LISTING /tmp/cc9TtpNu.s 			page 27


  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
GAS LISTING /tmp/cc9TtpNu.s 			page 28


 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
GAS LISTING /tmp/cc9TtpNu.s 			page 29


 671               		.stabn	68,0,187,.LM57-.LFBB11
 672               	.LM57:
 673 0004 EFE3      		ldi r30,lo8(-25537)
 674 0006 FCE9      		ldi r31,hi8(-25537)
 675 0008 3197      	1:	sbiw r30,1
 676 000a 01F4      		brne 1b
 677 000c 00C0      		rjmp .
 678 000e 0000      		nop
 679               	.LBE16:
 680               	.LBE15:
 681               		.stabs	"CDC.c",132,0,0,.Ltext4
 682               	.Ltext4:
 220:CDC.c         **** 		result = true;
 221:CDC.c         **** 	_delay_ms(10);
 222:CDC.c         **** 	return result;
 683               		.stabn	68,0,222,.LM58-.LFBB11
 684               	.LM58:
 685 0010 81E0      		ldi r24,lo8(1)
 686 0012 9111      		cpse r25,__zero_reg__
 687 0014 00C0      		rjmp .L29
 688 0016 80E0      		ldi r24,0
 689               	.L29:
 223:CDC.c         **** }
 690               		.stabn	68,0,223,.LM59-.LFBB11
 691               	.LM59:
 692 0018 0895      		ret
 693               		.size	Serial_test, .-Serial_test
 694               	.Lscope11:
 695               		.stabs	"",36,0,0,.Lscope11-.LFBB11
 696               		.stabd	78,0,0
 697               	.global	_serial_Peek
 698               		.section	.data._serial_Peek,"aw",@progbits
 699               		.type	_serial_Peek, @object
 700               		.size	_serial_Peek, 2
 701               	_serial_Peek:
 702 0000 FFFF      		.word	-1
 703               	.global	_cdcInterface
 704               		.section	.progmem.data._cdcInterface,"a",@progbits
 705               		.type	_cdcInterface, @object
 706               		.size	_cdcInterface, 66
 707               	_cdcInterface:
 708 0000 08        		.byte	8
 709 0001 0B        		.byte	11
 710 0002 00        		.byte	0
 711 0003 02        		.byte	2
 712 0004 02        		.byte	2
 713 0005 02        		.byte	2
 714 0006 01        		.byte	1
 715 0007 00        		.byte	0
 716 0008 09        		.byte	9
 717 0009 04        		.byte	4
 718 000a 00        		.byte	0
 719 000b 00        		.byte	0
 720 000c 01        		.byte	1
 721 000d 02        		.byte	2
 722 000e 02        		.byte	2
 723 000f 00        		.byte	0
GAS LISTING /tmp/cc9TtpNu.s 			page 30


 724 0010 00        		.byte	0
 725 0011 05        		.byte	5
 726 0012 24        		.byte	36
 727 0013 00        		.byte	0
 728 0014 10        		.byte	16
 729 0015 01        		.byte	1
 730 0016 05        		.byte	5
 731 0017 24        		.byte	36
 732 0018 01        		.byte	1
 733 0019 01        		.byte	1
 734 001a 01        		.byte	1
 735 001b 04        		.byte	4
 736 001c 24        		.byte	36
 737 001d 02        		.byte	2
 738 001e 06        		.byte	6
 739 001f 05        		.byte	5
 740 0020 24        		.byte	36
 741 0021 06        		.byte	6
 742 0022 00        		.byte	0
 743 0023 01        		.byte	1
 744 0024 07        		.byte	7
 745 0025 05        		.byte	5
 746 0026 81        		.byte	-127
 747 0027 03        		.byte	3
 748 0028 1000      		.word	16
 749 002a 40        		.byte	64
 750 002b 09        		.byte	9
 751 002c 04        		.byte	4
 752 002d 01        		.byte	1
 753 002e 00        		.byte	0
 754 002f 02        		.byte	2
 755 0030 0A        		.byte	10
 756 0031 00        		.byte	0
 757 0032 00        		.byte	0
 758 0033 00        		.byte	0
 759 0034 07        		.byte	7
 760 0035 05        		.byte	5
 761 0036 02        		.byte	2
 762 0037 02        		.byte	2
 763 0038 4000      		.word	64
 764 003a 00        		.byte	0
 765 003b 07        		.byte	7
 766 003c 05        		.byte	5
 767 003d 83        		.byte	-125
 768 003e 02        		.byte	2
 769 003f 4000      		.word	64
 770 0041 00        		.byte	0
 771               		.section	.data._usbLineInfo,"aw",@progbits
 772               		.type	_usbLineInfo, @object
 773               		.size	_usbLineInfo, 8
 774               	_usbLineInfo:
 775 0000 00        		.byte	0
 776 0001 E1        		.byte	-31
 777 0002 00        		.byte	0
 778 0003 00        		.byte	0
 779 0004 00        		.byte	0
 780 0005 00        		.byte	0
GAS LISTING /tmp/cc9TtpNu.s 			page 31


 781 0006 00        		.byte	0
 782 0007 00        		.byte	0
 783               		.comm	_cdc_rx_buffer,2,1
 784               	.global	cdc_rx_buffer
 785               		.section	.bss.cdc_rx_buffer,"aw",@nobits
 786               		.type	cdc_rx_buffer, @object
 787               		.size	cdc_rx_buffer, 68
 788               	cdc_rx_buffer:
 789 0000 0000 0000 		.zero	68
 789      0000 0000 
 789      0000 0000 
 789      0000 0000 
 789      0000 0000 
 790               		.stabs	"SDA:c=i2",128,0,0,0
 791               		.stabs	"SCL:c=i3",128,0,0,0
 792               		.stabs	"SS:c=i17",128,0,0,0
 793               		.stabs	"MOSI:c=i16",128,0,0,0
 794               		.stabs	"MISO:c=i14",128,0,0,0
 795               		.stabs	"SCK:c=i15",128,0,0,0
 796               		.stabs	"A0:c=i18",128,0,0,0
 797               		.stabs	"A1:c=i19",128,0,0,0
 798               		.stabs	"A2:c=i20",128,0,0,0
 799               		.stabs	"A3:c=i21",128,0,0,0
 800               		.stabs	"A4:c=i22",128,0,0,0
 801               		.stabs	"A5:c=i23",128,0,0,0
 802               		.stabs	"A6:c=i24",128,0,0,0
 803               		.stabs	"A7:c=i25",128,0,0,0
 804               		.stabs	"A8:c=i26",128,0,0,0
 805               		.stabs	"A9:c=i27",128,0,0,0
 806               		.stabs	"A10:c=i28",128,0,0,0
 807               		.stabs	"A11:c=i29",128,0,0,0
 808               		.stabs	"_usbLineInfo:S(0,59)=B(0,55)",38,0,48,_usbLineInfo
 809               		.stabs	"cdc_rx_buffer:G(0,54)",32,0,36,0
 810               		.stabs	"_cdc_rx_buffer:G(0,60)=*(0,54)",32,0,37,0
 811               		.stabs	"_cdcInterface:G(0,61)=k(13,19)",32,0,51,0
 812               		.stabs	"_serial_Peek:G(0,1)",32,0,128,0
 813               		.text
 814               		.stabs	"",100,0,0,.Letext0
 815               	.Letext0:
 816               		.ident	"GCC: (GNU) 5.4.0"
 817               	.global __do_copy_data
 818               	.global __do_clear_bss
GAS LISTING /tmp/cc9TtpNu.s 			page 32


DEFINED SYMBOLS
                            *ABS*:0000000000000000 CDC.c
     /tmp/cc9TtpNu.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc9TtpNu.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc9TtpNu.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc9TtpNu.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc9TtpNu.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc9TtpNu.s:153    .text.CDC_GetInterface:0000000000000000 CDC_GetInterface
     /tmp/cc9TtpNu.s:707    .progmem.data._cdcInterface:0000000000000000 _cdcInterface
     /tmp/cc9TtpNu.s:185    .text.CDC_Setup:0000000000000000 CDC_Setup
     /tmp/cc9TtpNu.s:774    .data._usbLineInfo:0000000000000000 _usbLineInfo
     /tmp/cc9TtpNu.s:350    .text.Serial_begin:0000000000000000 Serial_begin
     /tmp/cc9TtpNu.s:368    .text.Serial_end:0000000000000000 Serial_end
     /tmp/cc9TtpNu.s:386    .text.Serial_accept:0000000000000000 Serial_accept
     /tmp/cc9TtpNu.s:788    .bss.cdc_rx_buffer:0000000000000000 cdc_rx_buffer
     /tmp/cc9TtpNu.s:438    .text.Serial_available:0000000000000000 Serial_available
     /tmp/cc9TtpNu.s:468    .text.Serial_peek:0000000000000000 Serial_peek
     /tmp/cc9TtpNu.s:511    .text.Serial_read:0000000000000000 Serial_read
     /tmp/cc9TtpNu.s:571    .text.Serial_flush:0000000000000000 Serial_flush
     /tmp/cc9TtpNu.s:593    .text.Serial_write:0000000000000000 Serial_write
     /tmp/cc9TtpNu.s:655    .text.Serial_test:0000000000000000 Serial_test
     /tmp/cc9TtpNu.s:701    .data._serial_Peek:0000000000000000 _serial_Peek
                            *COM*:0000000000000002 _cdc_rx_buffer

UNDEFINED SYMBOLS
USB_SendControl
USB_RecvControl
USB_RecvNB
USB_Flush
USB_Send
__do_copy_data
__do_clear_bss
